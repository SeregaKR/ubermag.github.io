{
 "cells": [
  {
   "cell_type": "markdown",
   "source": [
    "# Region basics\n",
    "\n",
    "An object on which finite difference mesh, and accordingly, finite difference field are based is `Region`. In this tutorial, we show how to define a region as well as some basic operations.\n",
    "\n",
    "Region is always cubic and it can be defined by any two diagonally opposite corner points. For instance, let us assume we have a region in Cartesian coordinates with edge lengths:\n",
    "\n",
    "$$l_{x} = 100 \\,\\text{nm}$$\n",
    "$$l_{y} = 50 \\,\\text{nm}$$\n",
    "$$l_{z} = 20 \\,\\text{nm}$$\n",
    "\n",
    "In order to define this region we need to choose two diagonally opposite corner points. There are many possibilities, but it is up to us which corner points we are going to choose as well as where we are going to position our region in Cartesian coordinate system. Most often, we choose either:\n",
    "\n",
    "$$p_{1} = (0, 0, 0)$$\n",
    "$$p_{2} = (l_{x}, l_{y}, l_{z})$$\n",
    "\n",
    "or\n",
    "\n",
    "$$p_{1} = \\left(-\\frac{l_{x}}{2}, -\\frac{l_{y}}{2}, -\\frac{l_{z}}{2}\\right)$$\n",
    "$$p_{2} = \\left(\\frac{l_{x}}{2}, \\frac{l_{y}}{2}, \\frac{l_{z}}{2}\\right)$$\n",
    "\n",
    "For simplicity, we are going to position $p_{1}$ at the origin of the coordinate system.\n",
    "\n",
    "We define points as length-3 tuples and pass them to `Region` object via `p1` and `p2` arguments."
   ],
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "source": [
    "import discretisedfield as df  # df is here chosen to be an alias for discretisedfield\n",
    "\n",
    "p1 = (0, 0, 0)\n",
    "p2 = (100e-9, 50e-9, 20e-9)\n",
    "\n",
    "region = df.Region(p1=p1, p2=p2)"
   ],
   "outputs": [],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "(All units are SI and no prefixes are assumed. Therefore $1 \\,\\text{nm}$ is `1e-9`.)\n",
    "\n",
    "The region is now defined. Now, we are going to have a look at some basic methods (functions) which are part of the `Region` object.\n",
    "\n",
    "We can ask the region to give us the minimum and maximum points in the region."
   ],
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "source": [
    "region.pmin"
   ],
   "outputs": [
    {
     "output_type": "execute_result",
     "data": {
      "text/plain": [
       "(0.0, 0.0, 0.0)"
      ]
     },
     "metadata": {},
     "execution_count": 2
    }
   ],
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "source": [
    "region.pmax"
   ],
   "outputs": [
    {
     "output_type": "execute_result",
     "data": {
      "text/plain": [
       "(1e-07, 5e-08, 2e-08)"
      ]
     },
     "metadata": {},
     "execution_count": 3
    }
   ],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "In our case $p_\\text{min} = p_{1}$ and $p_\\text{max} = p_{2}$, only because of our choice of diagonally opposite points of the cubic region. In general, this is not the case, since we could have chosen any two points for $p_{1}$ and $p_{2}$.\n",
    "\n",
    "Now we can ask the region to give us the edge lengths of the region (based on $p_{1}$ and $p_{2}$ we used at the definition)."
   ],
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "source": [
    "region.edges"
   ],
   "outputs": [
    {
     "output_type": "execute_result",
     "data": {
      "text/plain": [
       "(1e-07, 5e-08, 2e-08)"
      ]
     },
     "metadata": {},
     "execution_count": 4
    }
   ],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "These lengths correspond to $l_{x}$, $l_{y}$, and $l_{z}$ we discussed earlier.\n",
    "\n",
    "Similarly, we can ask for a centre point in the region (cross section point of all diagonals)."
   ],
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "source": [
    "region.centre"
   ],
   "outputs": [
    {
     "output_type": "execute_result",
     "data": {
      "text/plain": [
       "(5e-08, 2.5e-08, 1e-08)"
      ]
     },
     "metadata": {},
     "execution_count": 5
    }
   ],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "Obviously, centre point we got is:\n",
    "\n",
    "$$p_\\text{c} = (\\frac{l_{x}}{2}, \\frac{l_{y}}{2}, \\frac{l_{z}}{2})$$\n",
    "\n",
    "The volume of the region is:"
   ],
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "source": [
    "region.volume"
   ],
   "outputs": [
    {
     "output_type": "execute_result",
     "data": {
      "text/plain": [
       "9.999999999999998e-23"
      ]
     },
     "metadata": {},
     "execution_count": 6
    }
   ],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "This value is in $\\text{m}^{3}$ and it is calculated as\n",
    "\n",
    "$$V=l_{x}l_{y}l_{z}$$\n",
    "\n",
    "Now, let us say we have a point $p$ and want to check if that point is in our region. We can do that using `in`. For instance, if our point is $p = (2\\,\\text{nm}, 4\\,\\text{nm}, 1\\,\\text{nm})$, we can ask the region if point $p$ is in it."
   ],
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "source": [
    "p = (2e-9, 4e-9, 1e-9)\n",
    "\n",
    "p in region"
   ],
   "outputs": [
    {
     "output_type": "execute_result",
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "metadata": {},
     "execution_count": 7
    }
   ],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "As a result, we get `bool` (either `True` or `False`). This can be useful, when we want to use these expressions as conditions for some more complex functions. For example:"
   ],
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "source": [
    "if p in region:\n",
    "    print('Point: I\\'m in! :)')\n",
    "else:\n",
    "    print('Point: I\\'m out! :(')"
   ],
   "outputs": [
    {
     "output_type": "stream",
     "name": "stdout",
     "text": [
      "Point: I'm in! :)\n"
     ]
    }
   ],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "On the other hand, we could have chosen a point which is outside of our region:"
   ],
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "source": [
    "(1e-9, 200e-9, 0) in region"
   ],
   "outputs": [
    {
     "output_type": "execute_result",
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "metadata": {},
     "execution_count": 9
    }
   ],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "Sometimes, we want any point which belongs to the region (usually for testing purposes) and we are too lazy to think. We can then ask the region to give us a random point."
   ],
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "source": [
    "# NBVAL_IGNORE_OUTPUT\n",
    "region.random_point()"
   ],
   "outputs": [
    {
     "output_type": "execute_result",
     "data": {
      "text/plain": [
       "(4.1187124756506165e-08, 7.449569099823344e-09, 3.7220525619063417e-10)"
      ]
     },
     "metadata": {},
     "execution_count": 10
    }
   ],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "Please note, that `random_point` is a function and not a property, unlike all the values we have looked at before. Therefore, we have to call it with parenthesis `()`.\n",
    "\n",
    "Sometimes we want to check if two regions are the same. We can do that using relational `==` operator. Let us define two regions: one which is the same to the one we have and one different:"
   ],
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "source": [
    "region_same = df.Region(p1=(0, 0, 0), p2=(100e-9, 50e-9, 20e-9))\n",
    "region_different = df.Region(p1=(0, 0, 0), p2=(10e-9, 5e-9, 2e-9))"
   ],
   "outputs": [],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "Now we can compare them:"
   ],
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "source": [
    "region == region_same"
   ],
   "outputs": [
    {
     "output_type": "execute_result",
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "metadata": {},
     "execution_count": 12
    }
   ],
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "source": [
    "region == region_different"
   ],
   "outputs": [
    {
     "output_type": "execute_result",
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "metadata": {},
     "execution_count": 13
    }
   ],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "Just like `in` operator, `==` returns `bool`. Similarly, we can ask if two regions are different:"
   ],
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "source": [
    "region != region_same"
   ],
   "outputs": [
    {
     "output_type": "execute_result",
     "data": {
      "text/plain": [
       "False"
      ]
     },
     "metadata": {},
     "execution_count": 14
    }
   ],
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "source": [
    "region != region_different"
   ],
   "outputs": [
    {
     "output_type": "execute_result",
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "metadata": {},
     "execution_count": 15
    }
   ],
   "metadata": {}
  },
  {
   "cell_type": "markdown",
   "source": [
    "Finally, we can ask the region object about its representation string:"
   ],
   "metadata": {}
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "source": [
    "repr(region)"
   ],
   "outputs": [
    {
     "output_type": "execute_result",
     "data": {
      "text/plain": [
       "'Region(p1=(0.0, 0.0, 0.0), p2=(1e-07, 5e-08, 2e-08))'"
      ]
     },
     "metadata": {},
     "execution_count": 16
    }
   ],
   "metadata": {}
  }
 ],
 "metadata": {
  "kernelspec": {
   "name": "python3",
   "display_name": "Python 3.8.10 64-bit ('ubermag-dev': conda)"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.10"
  },
  "interpreter": {
   "hash": "2940b2f637ab9684f43d9709170b64af8bd4a8fb93490cb82c1b85cca32aed36"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}